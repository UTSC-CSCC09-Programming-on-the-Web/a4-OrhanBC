import { Router } from "express";
import multer from "multer";
import path from "path";
import { Op } from "sequelize";

import { Image } from "../models/image.js";
import { Comment } from "../models/comment.js";
import { User } from "../models/user.js";
import {
  validateIdParam,
  validatePagination,
  validateImageInput,
  validateCommentInput,
} from "../utils/validators.js";

import { authenticate } from "../middleware/auth.middleware.js";

const upload = multer({
  dest: "uploads/",
  limits: {
    fileSize: 50 * 1024 * 1024, // 50MB limit
  },
});

export const router = Router();

// Remove the /first endpoint and use the main GET / endpoint with proper parameters

// Now /api/images?latest=true will get the latest image with navigation info
// this is generated by copilot
router.get("/", validatePagination, async (req, res) => {
  try {
    // Get validated parameters
    const limit = req.validatedQuery.limit || 1; // Default to 1 for this endpoint
    const cursor = req.query.cursor; // Raw cursor value, validation done in specific logic

    const isLatestRequest = req.query.latest === "true";
    const order = [["id", "DESC"]]; // Only using ID for ordering

    // Handle special case for requesting latest image with navigation
    if (isLatestRequest) {
      const firstImage = await Image.findOne({ order });

      if (!firstImage) {
        return res.status(404).json({ error: "No images found" });
      }

      const totalCount = await Image.count();

      // Get next image (older than first)
      const nextImage = await Image.findOne({
        where: {
          id: { [Op.lt]: firstImage.id },
        },
        order,
      });

      // Generate next cursor
      let nextCursor = null;
      if (nextImage) {
        nextCursor = nextImage.id.toString();
      }

      // Return in the same format as the standard pagination response
      return res.status(200).json({
        images: [firstImage],
        pagination: {
          hasNext: !!nextImage,
          nextCursor,
          hasPrev: false,
          prevCursor: null,
          total: totalCount,
          position: 1,
        },
      });
    }

    // Build the query conditions for standard pagination
    let where = {};

    // If cursor is provided, find images with ID less than or equal to the cursor
    if (cursor) {
      try {
        const cursorId = parseInt(cursor, 10);
        if (isNaN(cursorId)) {
          return res.status(400).json({ error: "Invalid cursor format" });
        }
        where = { id: { [Op.lte]: cursorId } }; // Changed from [Op.lt] to [Op.lte]
      } catch (error) {
        console.error("Invalid cursor:", error);
        return res.status(400).json({ error: "Invalid cursor format" });
      }
    }

    // Get one more item than requested to determine if there are more items
    const images = await Image.findAll({
      where,
      order,
      limit: limit + 1,
    });

    // Check if there are more items
    const hasNext = images.length > limit;

    // Remove the extra item if there are more
    const resultImages = hasNext ? images.slice(0, limit) : images;

    // Generate the next cursor
    let nextCursor = null;
    if (hasNext && resultImages.length > 0) {
      // Use the ID of the excluded next item as the cursor instead of the last shown item
      nextCursor = images[limit].id.toString();
    }

    // Generate the previous cursor
    let prevCursor = null;
    let hasPrev = false;

    if (resultImages.length > 0) {
      // Find if there are any images newer than the first image in our result set
      const firstResultImage = resultImages[0];

      const newerImagesCount = await Image.count({
        where: {
          id: { [Op.gt]: firstResultImage.id },
        },
      });

      hasPrev = newerImagesCount > 0;

      if (hasPrev) {
        // Find the newest image before our current batch for the prev cursor
        const newerImage = await Image.findOne({
          where: {
            id: { [Op.gt]: firstResultImage.id },
          },
          order: [["id", "ASC"]], // Get the closest ID
        });

        if (newerImage) {
          prevCursor = newerImage.id.toString();
        }
      }
    }

    // Get the total count for pagination info
    const totalCount = await Image.count();

    // Calculate position if we have images
    let position = 1;
    if (resultImages.length > 0) {
      const firstResultImage = resultImages[0];
      // Count images that have higher IDs (newer)
      const newerImagesCount = await Image.count({
        where: {
          id: { [Op.gt]: firstResultImage.id },
        },
      });
      position = newerImagesCount + 1;
    }

    res.status(200).json({
      images: resultImages,
      pagination: {
        hasNext,
        nextCursor,
        hasPrev,
        prevCursor,
        total: totalCount,
        position,
      },
    });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to retrieve images" });
  }
});

router.get("/:id", validateIdParam(), async (req, res) => {
  try {
    const image = await Image.findByPk(req.validatedParams.id);

    if (!image) {
      return res.status(404).json({ error: "Image not found" });
    }

    res.status(200).json(image);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to retrieve image" });
  }
});

router.delete("/:id", validateIdParam(), authenticate, async (req, res) => {
  try {
    const image = await Image.findByPk(req.validatedParams.id);

    if (!image) {
      return res.status(404).json({ error: "Image not found" });
    }

    if (req.userId !== image.UserId) {
      return res
        .status(403)
        .json({ error: "Forbidden: You can only delete your own images" });
    }

    await Comment.destroy({
      where: { imageId: req.params.id },
    });

    const filePath = path.resolve(
      process.cwd(),
      "uploads",
      image.image.filename,
    );
    try {
      const fs = await import("fs/promises");
      await fs.unlink(filePath);
    } catch (fileErr) {
      console.error("Error deleting file:", fileErr);
    }

    await image.destroy();
    res.status(204).send();
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to delete image" });
  }
});

router.get("/:id/image", validateIdParam(), async (req, res) => {
  try {
    const image = await Image.findByPk(req.validatedParams.id, {
      include: [
        {
          model: User,
          attributes: ["username"],
        },
      ],
    });

    if (!image) {
      return res.status(404).json({ error: "Image not found" });
    }

    res.sendFile(path.resolve(process.cwd(), "uploads", image.image.filename));
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "Failed to retrieve image" });
  }
});

router.get(
  "/:id/comments",
  validateIdParam(),
  validatePagination,
  authenticate,
  async (req, res) => {
    try {
      // All validation done by middleware
      const limit = req.validatedQuery.limit || 10;
      const offset = req.validatedQuery.offset || 0;

      // Find comments with pagination
      const { count, rows: comments } = await Comment.findAndCountAll({
        where: { ImageId: req.params.id },
        order: [["createdAt", "DESC"]],
        include: [
          {
            model: User,
            attributes: ["username"],
          },
        ],
        limit,
        offset,
      });

      res.status(200).json({
        comments,
        pagination: {
          total: count,
          offset,
          limit,
          hasMore: offset + comments.length < count,
        },
      });
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "Failed to retrieve comments" });
    }
  },
);

router.post(
  "/:id/comments",
  validateIdParam(),
  validateCommentInput,
  authenticate,
  async (req, res) => {
    try {
      const image = await Image.findByPk(req.validatedParams.id);

      if (!image) {
        return res.status(404).json({ error: "Image not found" });
      }

      const comment = await Comment.create({
        comment: req.body.comment,
        ImageId: image.id,
        UserId: req.userId,
      });
      res.status(201).json(comment);
    } catch (err) {
      console.error(err);
      res.status(500).json({ error: "Failed to add comment" });
    }
  },
);
