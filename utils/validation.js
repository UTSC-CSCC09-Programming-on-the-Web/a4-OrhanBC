/**
 * Validation utilities for API endpoints created by copilot
 */

/**
 * Validates password strength according to security requirements
 * @param {string} password - The password to validate
 * @returns {object} - { valid: boolean, error: string }
 *
 * Generated by GitHub Copilot
 */
export function validatePasswordStrength(password) {
  if (!password) {
    return { valid: false, error: "Password is required" };
  }

  const minLength = 8;

  if (password.length < minLength) {
    return {
      valid: false,
      error: `Password must be at least ${minLength} characters long`,
    };
  }

  // Check for complexity requirements
  const hasUppercase = /[A-Z]/.test(password);
  const hasLowercase = /[a-z]/.test(password);
  const hasNumber = /[0-9]/.test(password);
  const hasSpecialChar = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password);

  // Count how many criteria are met
  const criteriaCount = [
    hasUppercase,
    hasLowercase,
    hasNumber,
    hasSpecialChar,
  ].filter(Boolean).length;

  // Require at least 3 of the 4 criteria
  if (criteriaCount < 3) {
    return {
      valid: false,
      error:
        "Password must include at least 3 of the following: uppercase letters, lowercase letters, numbers, and special characters",
    };
  }

  return { valid: true };
}

/**
 * Validates that a parameter is a valid positive integer
 * @param {any} value - The value to validate
 * @param {number} [minValue=1] - The minimum allowed value
 * @returns {object} - { valid: boolean, value: number, error: string }
 */
export function validatePositiveInteger(value, minValue = 1) {
  if (value === undefined) {
    return { valid: true, value: undefined };
  }

  const parsedValue = parseInt(value, 10);

  if (isNaN(parsedValue)) {
    return {
      valid: false,
      error: `Must be a valid integer`,
    };
  }

  if (parsedValue < minValue) {
    return {
      valid: false,
      error: `Must be at least ${minValue}`,
    };
  }

  return { valid: true, value: parsedValue };
}

/**
 * Validates that a parameter is a valid ID
 * @param {any} value - The ID to validate
 * @returns {object} - { valid: boolean, value: number, error: string }
 */
export function validateId(value) {
  if (value === undefined) {
    return { valid: false, error: "ID is required" };
  }

  const parsedValue = parseInt(value, 10);

  if (isNaN(parsedValue)) {
    return {
      valid: false,
      error: "ID must be a valid integer",
    };
  }

  return { valid: true, value: parsedValue };
}

/**
 * Validates that required field is present and of the correct type
 * @param {any} value - The value to validate
 * @param {string} fieldName - The name of the field
 * @param {string} type - The expected type ('string', 'number', etc.)
 * @param {boolean} [required=true] - Whether the field is required
 * @returns {object} - { valid: boolean, error: string }
 */
export function validateField(
  value,
  fieldName,
  type = "string",
  required = true,
) {
  // Check if required field is present
  if (required && (value === undefined || value === null || value === "")) {
    return {
      valid: false,
      error: `${fieldName} is required`,
    };
  }

  // If not required and not provided, it's valid
  if (!required && (value === undefined || value === null || value === "")) {
    return { valid: true };
  }

  // Check type
  if (typeof value !== type) {
    return {
      valid: false,
      error: `${fieldName} must be a ${type}`,
    };
  }

  return { valid: true };
}

/**
 * Validates multiple fields at once
 * @param {object} body - The request body with fields to validate
 * @param {object} fieldRules - Rules for each field { fieldName: { type, required } }
 * @returns {object} - { valid: boolean, errors: object }
 */
export function validateFields(body, fieldRules) {
  const errors = {};
  let valid = true;

  for (const [fieldName, rules] of Object.entries(fieldRules)) {
    const { type = "string", required = true } = rules;
    const value = body[fieldName];
    const validation = validateField(value, fieldName, type, required);

    if (!validation.valid) {
      errors[fieldName] = validation.error;
      valid = false;
    }
  }

  return { valid, errors };
}

/**
 * Middleware for validating request parameters
 * @param {object} req - Express request object
 * @param {object} res - Express response object
 * @param {function} rules - Rules function that returns validations for the request
 * @returns {boolean} - Whether validation passed
 */
export function validateRequest(req, res, rules) {
  const validations = rules(req);
  const errors = {};
  let hasErrors = false;

  // Process all validations
  for (const [key, validation] of Object.entries(validations)) {
    if (!validation.valid) {
      errors[key] = validation.error;
      hasErrors = true;
    }
  }

  // If there are errors, send 422 response
  if (hasErrors) {
    res.status(422).json({
      error: "Validation failed",
      details: errors,
    });
    return false;
  }

  return true;
}

/**
 * Validates cursor format
 * @param {string} cursor - The cursor to validate
 * @returns {object} - { valid: boolean, value: number, error: string }
 */
export function validateCursor(cursor) {
  if (cursor === undefined) {
    return { valid: true, value: undefined };
  }

  if (typeof cursor !== "string" || cursor.trim() === "") {
    return {
      valid: false,
      error: "Cursor must be a valid string",
    };
  }

  try {
    const cursorId = parseInt(cursor, 10);
    if (isNaN(cursorId)) {
      return {
        valid: false,
        error: "Invalid cursor format",
      };
    }

    return { valid: true, value: cursorId };
  } catch (error) {
    return {
      valid: false,
      error: "Invalid cursor format",
    };
  }
}
